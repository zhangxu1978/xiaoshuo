<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>章节列表</title>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <style>
        body {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .chapter-item {
            padding: 15px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .chapter-item:hover {
            background-color: #f5f5f5;
        }
        .edit-buttons {
            display: none;
        }
        .chapter-item:hover .edit-buttons {
            display: block;
        }
        .add-chapter-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .back-btn {
            margin: 20px;
            padding: 10px 20px;
            background-color: #666;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .setting-btn {
            margin: 10px;
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            height: 80%;
            overflow-y: auto;
            transition: all 0.3s ease;
        }
        .modal-header {
            padding: 0px 10px 0px 10px;
            cursor: move;
            background-color: #f1f1f1;
            margin: -20px -20px 10px -20px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .close, .maximize, .minimize {
            color: #aaa;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            margin-left: 10px;
        }
        .maximize:hover,
        .minimize:hover,
        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .modal-content.maximized {
            margin: 0;
            width: 100%;
            height: 100%;
        }
        .modal-content.minimized {
            margin: 0;
            position: fixed;
            bottom: 0;
            right: 20px;
            width: 300px;
            height: 40px;
            overflow: hidden;
        }
        .modal-content.minimized .modal-header {
            margin: -20px -20px 0 -20px;
            height: 40px;
        }
        .modal-content.minimized textarea,
        .modal-content.minimized button,
        .modal-content.minimized iframe {
            display: none;
        }
        .loading-spinner {
            display: none;
            margin: 0 auto;
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <button class="back-btn" onclick="window.location.href='/bookshelf.html'">返回书架</button>
    <button class="setting-btn" onclick="showModal('environment')">世界设定</button>
    <button class="setting-btn" onclick="showModal('worldTimeline')">世界时间线</button>
    <button class="setting-btn" onclick="showModal('characters')">人物设定</button>
    <button class="setting-btn" onclick="showModal('characterTimeline')">人物时间线</button>
    <button class="setting-btn" onclick="showModal('items')">物品设定</button>
    <button class="setting-btn" onclick="generateStaticPage()">生成静态页面</button>
    <button class="setting-btn" onclick="showAiModal()">问问ai</button>
    <h1 id="bookTitle">章节目录</h1>
    <div class="chapter-list" id="chapterList"></div>
    <button class="add-chapter-btn" id="addChapterBtn" style="display: none;">新增章节</button>

    <div id="myModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle"></h2>
                <div style="display: flex; align-items: center;">
                    <span class="minimize" onclick="toggleMinimize(event)">_</span>
                    <span class="maximize" onclick="toggleMaximize(event)">&square;</span>
                    <span class="close" onclick="closeModal()">&times;</span>
                </div>
            </div>
            <div id="modalControls" style="margin-bottom: 10px; display: none;">
                <select id="modalModelSelect" style="padding: 5px; margin-right: 10px;">
                    <!-- 模型选项将通过JavaScript动态加载 -->
                </select>
                <select id="modalNovelTypeSelect" style="padding: 5px; margin-right: 10px;">
                    <option value="玄幻">玄幻</option>
                    <option value="仙侠">仙侠</option>
                    <option value="科幻">科幻</option>
                    <option value="都市">都市</option>
                    <option value="历史">历史</option>
                    <option value="奇幻">奇幻</option>
                    <option value="武侠">武侠</option>
                    <option value="游戏">游戏</option>
                </select>
                <button onclick="generateModalWorldView()" style="padding: 5px 10px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">获取世界观</button>
            </div>
            <div id="characterControls" style="margin-bottom: 10px; display: none;">
                <select id="characterModelSelect" style="padding: 5px; margin-right: 10px;">
                    <!-- 模型选项将通过JavaScript动态加载 -->
                </select>
                <input type="checkbox" id="includeWorldView" checked style="margin-right: 5px;">
                <label for="includeWorldView" style="margin-right: 10px;">加载世界观</label>
                <button onclick="generateCharacters()" style="padding: 5px 10px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">构建人物及人物关系</button>
            </div>
            <div id="timelineControls" style="margin-bottom: 10px; display: none;">
                <select id="timelineModelSelect" style="padding: 5px; margin-right: 10px;">
                    <!-- 模型选项将通过JavaScript动态加载 -->
                </select>
                <input type="number" id="chapterCount" placeholder="章节数量" style="padding: 5px; margin-right: 10px; width: 100px;" min="1" value="50">
                <button onclick="generateChapterOutline()" style="padding: 5px 10px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">生成章节目录</button>
                <button onclick="regenerateChapterSummaries()" style="padding: 5px 10px; background-color: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">重新生成摘要</button>
            </div>
            <textarea id="modalText" style="width: 100%; height: 80%;"></textarea>
            <button onclick="saveModalContent()">保存</button>
        </div>
    </div>

    <div id="aiModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <h2>问问AI</h2>
                    <button class="setting-btn" style="margin: 0; padding: 5px 10px;" onclick="loadSettingToAi('environment')">载入环境</button>
                    <button class="setting-btn" style="margin: 0; padding: 5px 10px;" onclick="loadSettingToAi('characters')">载入人物</button>
                    <button class="setting-btn" style="margin: 0; padding: 5px 10px;" onclick="loadSettingToAi('timeline')">载入时间线</button>
                    <input type="number" id="chapterInput" placeholder="输入章节号" style="width: 100px; padding: 5px;">
                    <button class="setting-btn" style="margin: 0; padding: 5px 10px;" onclick="loadChapterToAi()">载入章节</button>
                    <select id="keywordSelect" style="padding: 5px;">
                        <option value="这是一部以______（星际殖民/蒸汽魔法/赛博江湖）为背景的______（类型）小说，核心想探讨______（主题），如何设计贯穿始终的核心冲突？&#13;&#10;请给三个颠覆______（传统修仙/末世求生/豪门恩怨）设定的创新方案，需包含世界观突变点与人物异化要素&#13;&#10;如果要在______（场景/道具/能力体系）中植入______（哲学概念/科学理论/历史隐喻），有哪些融合方式？">核心基因</option>
                        <option value="我要写【类型】的小说，帮我构建一个世界，然后构建主要角色，然后构建章节目录，章节目录也是角色时间线。分成5卷写好每卷的剧情摘要，每卷50章，设置好第一卷50章的章节目录和一句话的剧情摘要">构建世界</option>
                        <option value="根据我们构建的世界，帮我创作小说的第【】卷第【】章的内容，输出字数【】字">创作小说</option>
                        <option value="世界观">世界观</option>
                        <option value="剧情发展">剧情发展</option>
                        <option value="人物性格">人物性格</option>
                    </select>
                    <button class="setting-btn" style="margin: 0; padding: 5px 10px;" onclick="addKeywordToAi()">添加关键词</button>
                </div>
                <div style="display: flex; align-items: center;">
                    <span class="minimize" onclick="toggleMinimize(event)">_</span>
                    <span class="maximize" onclick="toggleMaximize(event)">&square;</span>
                    <span class="close" onclick="closeAiModal()">&times;</span>
                </div>
            </div>
            <iframe id="aiFrame" src="a.html" style="width: 100%; height: 80%; border: none;"></iframe>
        </div>
    </div>

    <!-- 添加章节重构模态框 -->
    <div id="reconstructModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <h2 style="text-align: center; color: #333; margin-bottom: 20px; font-size: 24px;">章节重构</h2>
            <div class="settings-container">
                <div class="setting-item" style="display: flex; gap: 20px; align-items: center; background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label style="white-space: nowrap;">模型:</label>
                        <select id="reconstructModelSelect" style="width: 120px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white;">
                            <option value="google-ai">谷歌AI</option>
                            <option value="deepseek-ai/DeepSeek-R1">deepseekR1</option>
                            <option value="deepseek-ai/DeepSeek-V3">deepseekV3</option>
                            <option value="Qwen/QVQ-72B-Preview">Qwen72BP</option>
                            <option value="deepseek-tianyi-ai">天翼AI</option>
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label style="white-space: nowrap;">
                            <input type="checkbox" id="loadWorldview" checked style="margin-right: 5px;"/>
                            加载世界观
                        </label>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label style="white-space: nowrap;">章节范围:</label>
                        <input type="number" id="prevChaptersCount" style="width: 50px; padding: 6px; border: 1px solid #ddd; border-radius: 4px;" min="0" max="10" value="3"/>
                        <span>章前</span>
                        <input type="number" id="nextChaptersCount" style="width: 50px; padding: 6px; border: 1px solid #ddd; border-radius: 4px;" min="0" max="10" value="0"/>
                        <span>章后</span>
                    </div>
                </div>
                <div class="setting-item">
                    <label style="display: block; margin-bottom: 10px; color: #333; font-weight: bold;">重构要求:</label>
                    <textarea id="reconstructRequirements" style="width: 95%; height: 250px; padding: 15px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; line-height: 1.6; resize: vertical; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);" placeholder="请输入重构要求，例如：
1. 保持原有剧情框架，增加细节描写
2. 加强人物心理活动的刻画
3. 优化场景描写的细节
4. 调整对话的节奏感
...">1. 保持原有剧情框架，增加细节描写
2. 加强人物心理活动的刻画
3. 重构第【】章的内容
4. 字数2000</textarea>
                </div>
            </div>
            <div class="modal-buttons" style="margin-top: 20px; display: flex; justify-content: flex-end; gap: 15px; align-items: center;">
                <div class="loading-spinner" id="reconstructSpinner" style="margin-right: 10px;"></div>
                <button class="modal-btn cancel" style="padding: 10px 25px; font-size: 16px;" onclick="closeReconstructModal()">取消</button>
                <button class="modal-btn confirm" style="padding: 10px 25px; font-size: 16px;" onclick="startReconstruct()">开始重构</button>
            </div>
        </div>
    </div>

    <script>
        let currentUser = null;
        let currentBook = null;
        const bookId = new URLSearchParams(window.location.search).get('bookId');

        // 检查登录状态
        async function checkLoginStatus() {
            try {
                const response = await fetch('/api/check-login');
                const data = await response.json();
                if (!data.success) {
                    window.location.href = '/index.html';
                }
                currentUser = data.user;
                loadBookDetails();
            } catch (error) {
                console.error('检查登录状态失败:', error);
                window.location.href = '/index.html';
            }
        }

        // 加载书籍详情
        async function loadBookDetails() {
            try {
                const response = await fetch(`/api/books/${bookId}`);
                const book = await response.json();
                currentBook = book;
                document.getElementById('bookTitle').textContent = book.title;
                
                // 如果是作者，显示添加章节按钮
                if (currentUser.username === book.author) {
                    document.getElementById('addChapterBtn').style.display = 'block';
                }
                
                loadChapters();
            } catch (error) {
                console.error('加载书籍详情失败:', error);
            }
        }

        // 加载章节列表
        async function loadChapters() {
            try {
                const response = await fetch(`/api/books/${bookId}/chapters`);
                const chapters = await response.json();
                const chapterList = document.getElementById('chapterList');
                chapterList.innerHTML = '';

                chapters.forEach(chapter => {
                    const chapterItem = document.createElement('div');
                    chapterItem.className = 'chapter-item';
                    chapterItem.innerHTML = `
                        <span>${chapter.title}</span>
                        <div class="edit-buttons">
                            ${currentUser.username === currentBook.author ? 
                                `<button onclick="showReconstructChapter(${chapter.id})" style="background-color: #ff5722; color: white;">章节重构</button>
                                 <button onclick="editChapter(${chapter.id})">编辑</button>
                                 <button onclick="deleteChapter(${chapter.id})">删除</button>` 
                                : ''}
                        </div>
                    `;
                    chapterItem.onclick = (e) => {
                        if (!e.target.matches('button')) {
                            window.location.href = `/reader.html?bookId=${bookId}&chapterId=${chapter.id}`;
                        }
                    };
                    chapterList.appendChild(chapterItem);
                });
            } catch (error) {
                console.error('加载章节失败:', error);
            }
        }

        // 编辑章节
        async function editChapter(chapterId) {
            window.location.href = `/editor.html?bookId=${bookId}&chapterId=${chapterId}`;
        }

        // 删除章节
        async function deleteChapter(chapterId) {
            if (confirm('确定要删除这个章节吗？')) {
                try {
                    const response = await fetch(`/api/chapters/${chapterId}?bookId=${bookId}`, {
                        method: 'DELETE'
                    });
                    const result = await response.json();
                    if (result.success) {
                        loadChapters();
                    } else {
                        alert('删除章节失败: ' + result.message);
                    }
                } catch (error) {
                    console.error('删除章节失败:', error);
                    alert('删除章节失败');
                }
            }
        }

        // 显示模态框
        function showModal(type) {
            const modal = document.getElementById('myModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalText = document.getElementById('modalText');
            const modalControls = document.getElementById('modalControls');
            const characterControls = document.getElementById('characterControls');
            const timelineControls = document.getElementById('timelineControls');
            modal.style.display = 'block';
            modalTitle.textContent = type + ' 设定';
            
            // 根据类型显示不同的控制元素
            modalControls.style.display = type === 'environment' ? 'block' : 'none';
            characterControls.style.display = type === 'characters' ? 'block' : 'none';
            timelineControls.style.display = type === 'characterTimeline' ? 'block' : 'none';
            
            fetch(`/api/settings/${type}?bookId=${bookId}`)
                .then(response => response.json())
                .then(data => {
                    modalText.value = data.value || '';
                })
                .catch(error => {
                    console.error('获取设定失败:', error);
                    modalText.value = '';
                });
        }

        // 关闭模态框
        function closeModal() {
            const modal = document.getElementById('myModal');
            const modalContent = modal.querySelector('.modal-content');
            modalContent.classList.remove('maximized', 'minimized');
            modal.style.backgroundColor = 'rgba(0,0,0,0.4)';
            modal.style.display = 'none';
        }

        // 保存模态框内容
        function saveModalContent() {
            const modalText = document.getElementById('modalText');
            const modalTitle = document.getElementById('modalTitle');
            const type = modalTitle.textContent.split(' ')[0].toLowerCase();
            fetch(`/api/settings/${type}?bookId=${bookId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ value: modalText.value })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    closeModal();
                } else {
                    alert('保存设定失败: ' + data.message);
                }
            })
            .catch(error => {
                console.error('保存设定失败:', error);
                alert('保存设定失败');
            });
        }

        // 生成静态页面
        async function generateStaticPage() {
            try {
                // 获取书籍信息和章节列表
                const bookResponse = await fetch(`/api/books/${bookId}`);
                const book = await bookResponse.json();
                
                const chaptersResponse = await fetch(`/api/books/${bookId}/chapters`);
                const chapters = await chaptersResponse.json();

                // 生成静态HTML内容
                const staticHtml = `
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>${book.title}</title>
    <style>
        body {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        .chapter-list {
            list-style: none;
            padding: 0;
        }
        .chapter-item {
            padding: 15px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }
        .chapter-item:hover {
            background-color: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #333;
        }
    </style>
</head>
<body>
    <h1>${book.title}</h1>
    <div class="chapter-list">
        ${chapters.map(chapter => `
            <div class="chapter-item" onclick="window.location.href='chapter_${chapter.id}.html'">
                ${chapter.title}
            </div>
        `).join('')}
    </div>
</body>
</html>`;

                // 发送请求到服务器生成静态文件
                const response = await fetch('/api/generate-static', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        bookId: bookId,
                        html: staticHtml,
                        chapters: chapters
                    })
                });

                const result = await response.json();
                if (result.success) {
                    alert('静态页面生成成功！访问路径：/static/' + bookId + '/index.html');
                } else {
                    alert('生成静态页面失败: ' + result.message);
                }
            } catch (error) {
                console.error('生成静态页面失败:', error);
                alert('生成静态页面失败');
            }
        }

        // 显示AI模态框
        function showAiModal() {
            const modal = document.getElementById('aiModal');
            modal.style.display = 'block';
        }

        // 关闭AI模态框
        function closeAiModal() {
            const modal = document.getElementById('aiModal');
            const modalContent = modal.querySelector('.modal-content');
            modalContent.classList.remove('maximized', 'minimized');
            modal.style.backgroundColor = 'rgba(0,0,0,0.4)';
            modal.style.display = 'none';
        }

        // 加载设定内容到AI iframe
        async function loadSettingToAi(type) {
            try {
                const response = await fetch(`/api/settings/${type}?bookId=${bookId}`);
                const data = await response.json();
                const content = data.value || '';
                
                // 获取iframe并设置内容到user-input输入框
                const aiFrame = document.getElementById('aiFrame');
                const userInput = aiFrame.contentDocument.getElementById('user-input');
                if (userInput) {
                    userInput.value += content;
                    // 触发input事件以调整输入框高度
                    const event = new Event('input', { bubbles: true });
                    userInput.dispatchEvent(event);
                }
            } catch (error) {
                console.error('加载设定失败:', error);
                alert('加载设定失败');
            }
        }

        // 加载章节内容到AI iframe
        async function loadChapterToAi() {
            try {
                const chapterInput = document.getElementById('chapterInput');
                const chapterId = chapterInput.value;
                
                if (!chapterId) {
                    alert('请输入章节号');
                    return;
                }

                const response = await fetch(`/api/chapters/${chapterId}?bookId=${bookId}`);
                const data = await response.json();
                
                if (!data.content) {
                    alert('未找到该章节内容');
                    return;
                }

                // 获取iframe并设置内容到user-input输入框
                const aiFrame = document.getElementById('aiFrame');
                const userInput = aiFrame.contentDocument.getElementById('user-input');
                if (userInput) {
                    userInput.value += '\n\n第' + chapterId + '章内容：\n' + data.content;
                    // 触发input事件以调整输入框高度
                    const event = new Event('input', { bubbles: true });
                    userInput.dispatchEvent(event);
                }
            } catch (error) {
                console.error('加载章节失败:', error);
                alert('加载章节失败');
            }
        }

        // 添加关键词到AI iframe
        function addKeywordToAi() {
            const keywordSelect = document.getElementById('keywordSelect');
            const selectedKeyword = keywordSelect.value.replace(/&#13;&#10;/g, '\n');
            
            const aiFrame = document.getElementById('aiFrame');
            const userInput = aiFrame.contentDocument.getElementById('user-input');
            if (userInput) {
                // 如果当前输入框已有内容，先添加两个换行符
                if (userInput.value.trim() !== '') {
                    userInput.value += '\n\n';
                }
                userInput.value += selectedKeyword;
                // 触发input事件以调整输入框高度
                const event = new Event('input', { bubbles: true });
                userInput.dispatchEvent(event);
            }
        }

        // 切换最大化状态
        function toggleMaximize(event) {
            const modalContent = event.target.closest('.modal-content');
            const modal = modalContent.parentElement;
            
            // 如果当前是最小化状态，先恢复正常大小
            if (modalContent.classList.contains('minimized')) {
                toggleMinimize(event);
            }
            
            modalContent.classList.toggle('maximized');
            
            // 更新最大化按钮的图标
            const maximizeBtn = event.target;
            if (modalContent.classList.contains('maximized')) {
                maximizeBtn.innerHTML = '&#9744;'; // 显示还原图标
            } else {
                maximizeBtn.innerHTML = '&#9633;'; // 显示最大化图标
            }
        }

        // 切换最小化状态
        function toggleMinimize(event) {
            const modalContent = event.target.closest('.modal-content');
            const modal = modalContent.parentElement;
            
            // 如果当前是最大化状态，先恢复正常大小
            if (modalContent.classList.contains('maximized')) {
                modalContent.classList.remove('maximized');
                event.target.previousElementSibling.innerHTML = '&#9633;';
            }
            
            modalContent.classList.toggle('minimized');
            
            // 切换蒙版显示
            if (modalContent.classList.contains('minimized')) {
                modal.style.backgroundColor = 'transparent';
            } else {
                modal.style.backgroundColor = 'rgba(0,0,0,0.4)';
            }
        }

        // 在模态框中生成世界观
        async function generateModalWorldView() {
            const modelSelect = document.getElementById('modalModelSelect');
            const novelTypeSelect = document.getElementById('modalNovelTypeSelect');
            const selectedModel = modelSelect.value;
            const novelType = novelTypeSelect.value;
            const modalText = document.getElementById('modalText');

            // 构建提示词
            const prompt = `请你作为一个专业的小说策划师，为我构建一个完整的${novelType}类型小说的世界观设定。
需要包含以下要素：
1. 世界背景：整体世界观的基本设定，包括时代背景、空间结构等
2. 核心法则：该世界运行的基本规则，如修炼体系、科技水平、力量体系等
3. 主要势力：世界中的主要势力分布和特点
4. 特殊元素：独特的物品、生物、现象等
5. 文明特征：世界中的文明发展水平、文化特点等
6. 冲突源：潜在的矛盾点和冲突来源

请详细描述每个方面，使其既符合${novelType}小说的特点，又具有独特性和创新性。`;

            try {
                modalText.value = '正在生成世界观设定...';
                
                if (selectedModel === 'google-ai') {
                    // 调用谷歌 AI API
                    const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=AIzaSyAxPOoOh-zAvC7FoFaxKd15E1NDGKhotAI';
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                role: "user",
                                parts: [{ text: prompt }]
                            }]
                        })
                    });

                    const result = await response.json();
                    if (result.candidates && result.candidates[0] && result.candidates[0].content) {
                        modalText.value = result.candidates[0].content.parts[0].text;
                    } else {
                        modalText.value = '生成失败：未获取到有效响应';
                    }
                } else {
                    // 其他模型通过服务器处理
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            messages: [
                                {
                                    role: "system",
                                    content: config.systemPrompts.novel
                                },
                                {
                                    role: "user",
                                    content: prompt
                                }
                            ],
                            model: selectedModel,
                            temperature: 0.7,
                            top_p: 0.9,
                            max_tokens: 8000
                        })
                    });

                    const result = await response.json();
                    if (result.choices && result.choices[0]) {
                        modalText.value = result.choices[0].message.content;
                    } else {
                        modalText.value = '生成失败：未获取到有效响应';
                    }
                }
            } catch (error) {
                console.error('生成世界观失败:', error);
                modalText.value = '生成世界观失败，请重试';
            }
        }

        // 添加生成人物的函数
        async function generateCharacters() {
            const modelSelect = document.getElementById('characterModelSelect');
            const includeWorldView = document.getElementById('includeWorldView');
            const selectedModel = modelSelect.value;
            const modalText = document.getElementById('modalText');
            let worldViewContent = '';

            if (includeWorldView.checked) {
                try {
                    const response = await fetch(`/api/settings/environment?bookId=${bookId}`);
                    const data = await response.json();
                    worldViewContent = data.value || '';
                } catch (error) {
                    console.error('获取世界观失败:', error);
                }
            }

            // 构建提示词
            const prompt = `请你作为一个专业的小说策划师，${includeWorldView.checked ? '基于以下世界观：\n\n' + worldViewContent + '\n\n' : ''}为我构建一组完整的小说人物设定。
需要包含以下要素：
1. 主要人物：详细描述每个主要人物的性格特征、背景故事、能力特点等
2. 次要人物：简要描述重要的配角人物
3. 人物关系：描述主要人物之间的关系网络
4. 成长轨迹：主要人物可能的成长方向和发展路线
5. 矛盾冲突：人物之间潜在的矛盾点和冲突源
6. 个性特征：每个主要人物独特的性格特点和行为模式

请详细描述每个方面，使人物形象丰满立体，性格特点鲜明，关系网络合理。`;

            try {
                modalText.value = '正在生成人物设定...';
                
                if (selectedModel === 'google-ai') {
                    // 调用谷歌 AI API
                    const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=AIzaSyAxPOoOh-zAvC7FoFaxKd15E1NDGKhotAI';
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                role: "user",
                                parts: [{ text: prompt }]
                            }]
                        })
                    });

                    const result = await response.json();
                    if (result.candidates && result.candidates[0] && result.candidates[0].content) {
                        modalText.value = result.candidates[0].content.parts[0].text;
                    } else {
                        modalText.value = '生成失败：未获取到有效响应';
                    }
                } else {
                    // 其他模型通过服务器处理
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            messages: [
                                {
                                    role: "system",
                                    content:config.systemPrompts.novel-character
                                },
                                {
                                    role: "user",
                                    content: prompt
                                }
                            ],
                            model: selectedModel,
                            temperature: 0.7,
                            top_p: 0.9,
                            max_tokens: 8000
                        })
                    });

                    const result = await response.json();
                    if (result.choices && result.choices[0]) {
                        modalText.value = result.choices[0].message.content;
                    } else {
                        modalText.value = '生成失败：未获取到有效响应';
                    }
                }
            } catch (error) {
                console.error('生成人物设定失败:', error);
                modalText.value = '生成人物设定失败，请重试';
            }
        }

        // 页面加载完成后执行
        document.addEventListener('DOMContentLoaded', () => {
            if (!bookId) {
                window.location.href = '/bookshelf.html';
                return;
            }
            checkLoginStatus();

            // 添加新章节的事件处理
            document.getElementById('addChapterBtn').onclick = async () => {
                window.location.href = `/editor.html?bookId=${bookId}`;
            };
    // 定义一个系数来加快拖动速度，这里设置为 2，你可以根据需要调整
   // const speedFactor = 5; 
            // 拖动模态框
            interact('.modal-content')
                .draggable({
                    allowFrom: '.modal-header',
                    listeners: {
                        move: function (event) {
                            const target = event.target;
                            const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                            const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

                            target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';
                            target.setAttribute('data-x', x);
                            target.setAttribute('data-y', y);
                        }
                    }
                });
        });

        async function generateChapterOutline() {
            const modelSelect = document.getElementById('timelineModelSelect');
            const chapterCount = document.getElementById('chapterCount').value;
            const modalText = document.getElementById('modalText');
            const selectedModel = modelSelect.value;

            try {
                // 获取世界观和人物设定
                const worldviewResponse = await fetch(`/api/settings/environment?bookId=${bookId}`);
                const worldviewData = await worldviewResponse.json();
                const worldview = worldviewData.value || '';

                const charactersResponse = await fetch(`/api/settings/characters?bookId=${bookId}`);
                const charactersData = await charactersResponse.json();
                const characters = charactersData.value || '';

                const prompt = `请根据以下世界观和人物设定，生成${chapterCount}章的小说章节目录。
每章的格式必须严格按照："章节序号，章节名称，一句话介绍【登场人物】"一句话介绍字数100字左右，写清楚本章的剧情，例如：
1，初入修仙界，少年踏上修行之路...【张三】
2，寻找灵药，意外发现上古遗迹...【张三||李四】
...

世界观设定：
${worldview}

人物设定：
${characters}

请生成${chapterCount}章的章节目录，确保每章都符合世界观和人物设定，并且故事情节连贯，富有张力。`;

                modalText.value = '正在生成章节目录...';

                let response;
                let result;

                if (selectedModel === 'google-ai') {
                    // 调用谷歌 AI API
                    const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=AIzaSyAxPOoOh-zAvC7FoFaxKd15E1NDGKhotAI';
                    response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                role: "user",
                                parts: [{ text: prompt }]
                            }]
                        })
                    });
                    result = await response.json();
                    if (result.candidates && result.candidates[0] && result.candidates[0].content) {
                        modalText.value = result.candidates[0].content.parts[0].text;
                        await generateSummariesFromOutline(modalText.value);
                    } else {
                        modalText.value = '生成失败：未获取到有效响应';
                    }
                } else {
                    // 其他模型通过服务器处理
                    response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            messages: [
                                {
                                    role: "system",
                                    content:config.systemPrompts.novel-timeline
                                },
                                {
                                    role: "user",
                                    content: prompt
                                }
                            ],
                            model: selectedModel,
                            temperature: 0.7,
                            top_p: 0.9,
                            max_tokens: 8000
                        })
                    });
                    result = await response.json();
                    if (result.choices && result.choices[0]) {
                        modalText.value = result.choices[0].message.content;
                        await generateSummariesFromOutline(modalText.value);
                    } else {
                        modalText.value = '生成失败：未获取到有效响应';
                    }
                }
            } catch (error) {
                console.error('生成章节目录失败:', error);
                modalText.value = '生成章节目录失败，请重试';
            }
        }

        async function generateSummariesFromOutline(outline) {
            try {
                const lines = outline.split('\n').filter(line => line.trim());
                const chapters = [];

                for (const line of lines) {
                    const match = line.match(/(\d+)，([^，]+)，(.+)/);
                    if (match) {
                        chapters.push({
                            chapterNumber: parseInt(match[1]),
                            title: match[2],
                            summary: match[3]
                        });
                    }
                }

                // 保存每个章节的摘要并创建章节
                for (const chapter of chapters) {
                    try {
                        // 创建章节
                        const createResponse = await fetch(`/api/chapters?bookId=${bookId}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                title: chapter.title,
                                content: '', // 初始内容为空
                                chapterNumber: chapter.chapterNumber
                            })
                        });
                        
                        const createResult = await createResponse.json();
                        if (createResult.success) {
                            // 保存章节设定
                            const settingsResponse = await fetch('/api/chapter-settings', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    bookId: parseInt(bookId),
                                    chapterId: chapter.chapterNumber,
                                    title: chapter.title,
                                    type: 'normal',
                                    status: 'draft',
                                    summary: chapter.summary
                                })
                            });
                            
                            const settingsResult = await settingsResponse.json();
                            if (!settingsResult.success) {
                                console.error(`保存第${chapter.chapterNumber}章设定失败:`, settingsResult.message);
                            }
                        } else {
                            console.error(`创建第${chapter.chapterNumber}章失败:`, createResult.message);
                        }
                    } catch (error) {
                        console.error(`处理第${chapter.chapterNumber}章失败:`, error);
                    }
                }
                
                // 重新加载章节列表
                await loadChapters();
            } catch (error) {
                console.error('处理章节目录失败:', error);
            }
        }

        async function regenerateChapterSummaries() {
            const modalText = document.getElementById('modalText');
            const currentContent = modalText.value;

            try {
                // 按行分割并过滤空行
                const lines = currentContent.split('\n').filter(line => line.trim());
                let allSummaries = '';
                let successCount = 0;

                for (const line of lines) {
                    // 使用正则表达式匹配格式：章节号，章节名称，摘要
                    const match = line.match(/^(\d+)，([^，]+)，(.+)$/);
                    if (!match) {
                        console.log('跳过不符合格式的行:', line);
                        continue;
                    }

                    const [_, chapterNumber, title, summary] = match;

                    try {
                        // 保存章节摘要
                        const response = await fetch('/api/chapter-settings', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                bookId: parseInt(bookId),
                                chapterId: parseInt(chapterNumber),
                                title: title,
                                type: 'normal',
                                status: 'draft',
                                summary: summary.trim()
                            })
                        });

                        const result = await response.json();
                        if (result.success) {
                            successCount++;
                            allSummaries += `${chapterNumber}，${title}，${summary.trim()}\n`;
                        } else {
                            console.error(`保存第${chapterNumber}章摘要失败:`, result.message);
                            allSummaries += `${chapterNumber}，${title}，保存失败\n`;
                        }
                    } catch (error) {
                        console.error(`处理第${chapterNumber}章摘要失败:`, error);
                        allSummaries += `${chapterNumber}，${title}，处理失败\n`;
                    }
                }

                modalText.value = allSummaries;
                alert(`摘要更新完成，成功处理 ${successCount} 章节。`);
            } catch (error) {
                console.error('重新生成摘要失败:', error);
                alert('重新生成摘要失败，请重试');
            }
        }

        // 显示章节重构弹窗
        function showReconstructChapter(chapterId) {
            const modal = document.getElementById('reconstructModal');
            modal.style.display = 'block';
            modal.setAttribute('data-chapter-id', chapterId);
        }

        // 关闭章节重构弹窗
        function closeReconstructModal() {
            const modal = document.getElementById('reconstructModal');
            modal.style.display = 'none';
        }

        // 开始重构章节
        async function startReconstruct() {
            const modal = document.getElementById('reconstructModal');
            const chapterId = modal.getAttribute('data-chapter-id');
            const modelSelect = document.getElementById('reconstructModelSelect');
            const loadWorldview = document.getElementById('loadWorldview').checked;
            const prevCount = parseInt(document.getElementById('prevChaptersCount').value);
            const nextCount = parseInt(document.getElementById('nextChaptersCount').value);
            const requirements = document.getElementById('reconstructRequirements').value;
            const spinner = document.getElementById('reconstructSpinner');

            if (!requirements.trim()) {
                alert('请输入重构要求');
                return;
            }

            try {
                spinner.style.display = 'block';
                
                // 获取当前章节内容
                const chapterResponse = await fetch(`/api/chapters/${chapterId}?bookId=${bookId}`);
                const chapterData = await chapterResponse.json();
                const currentContent = chapterData.content;
                
                // 构建上下文信息
                let context = '';
                
                // 如果需要加载世界观
                if (loadWorldview) {
                    try {
                        const worldviewResponse = await fetch(`/api/settings/environment?bookId=${bookId}`);
                        const worldviewData = await worldviewResponse.json();
                        if (worldviewData.success) {
                            context += '世界观设定：\n' + worldviewData.value + '\n\n';
                        }
                    } catch (error) {
                        console.error('加载世界观失败:', error);
                    }
                }

                // 获取前后章节摘要
                if (prevCount > 0 || nextCount > 0) {
                    try {
                        const summaryResponse = await fetch(`/api/chapter-summaries?bookId=${bookId}&chapterId=${chapterId}&prevCount=${prevCount}&nextCount=${nextCount}`);
                        const summaryData = await summaryResponse.json();
                        if (summaryData.success) {
                            context += '相关章节摘要：\n' + summaryData.summaries.join('\n\n') + '\n\n';
                        }
                    } catch (error) {
                        console.error('加载章节摘要失败:', error);
                    }
                }

                // 发送重构请求
                let reconstructedContent = '';
                if (modelSelect.value === 'google-ai') {
                    // 调用谷歌 AI API
                    const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=AIzaSyAxPOoOh-zAvC7FoFaxKd15E1NDGKhotAI';
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                role: "user",
                                parts: [{ 
                                    text: `你是一个专业的小说重构助手，请根据提供的上下文信息和要求，对章节内容进行重构。保持故事的连贯性和整体性。

${context}

原章节内容：
${currentContent}

重构要求：
${requirements}` 
                                }]
                            }]
                        })
                    });

                    const result = await response.json();
                    if (result.candidates && result.candidates[0] && result.candidates[0].content) {
                        reconstructedContent = result.candidates[0].content.parts[0].text;
                    } else {
                        throw new Error('未获取到有效响应');
                    }
                } else {
                    // 其他模型通过服务器处理
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            messages: [
                                {
                                    role: "system",
                                    content: config.systemPrompts.reconstructor
                                },
                                {
                                    role: "user",
                                    content: `${context}原章节内容：\n${currentContent}\n\n重构要求：\n${requirements}`
                                }
                            ],
                            model: modelSelect.value,
                            temperature: 0.7,
                            top_p: 0.9,
                            max_tokens: 8000
                        })
                    });

                    const result = await response.json();
                    if (result.choices && result.choices[0]) {
                        reconstructedContent = result.choices[0].message.content;
                    } else {
                        throw new Error('未获取到有效响应');
                    }
                }

                // 保存重构后的内容
                await fetch(`/api/chapters/${chapterId}?bookId=${bookId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        title: chapterData.title,
                        content: reconstructedContent
                    })
                });

                alert('章节重构完成');
                closeReconstructModal();
            } catch (error) {
                console.error('章节重构失败:', error);
                alert('重构失败，请重试');
            } finally {
                spinner.style.display = 'none';
            }
        }

        // 加载模型配置
        async function loadModelConfig() {
            try {
                const response = await fetch('/newbook/key.config');
                const config = await response.json();
                window.config = config; // 保存配置到全局变量
                
                // 获取所有模型选择下拉框
                const modelSelects = [
                    document.getElementById('modalModelSelect'),
                    document.getElementById('characterModelSelect'),
                    document.getElementById('timelineModelSelect')
                ];
                
                // 为每个下拉框添加选项
                modelSelects.forEach(select => {
                    if (select) {
                        // 清空现有选项
                        select.innerHTML = '';
                        
                        // 添加新选项
                        config.models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model.id;
                            option.textContent = model.name;
                            select.appendChild(option);
                        });
                    }
                });

                // 如果iframe存在，向其发送模型配置
                const aiFrame = document.getElementById('aiFrame');
                if (aiFrame && aiFrame.contentWindow) {
                    aiFrame.contentWindow.postMessage({
                        type: 'modelConfig',
                        config: config.models
                    }, '*');
                }
            } catch (error) {
                console.error('加载模型配置失败:', error);
            }
        }

        // 页面加载时调用
        document.addEventListener('DOMContentLoaded', loadModelConfig);
        
        // iframe加载完成后也发送配置
        document.getElementById('aiFrame').addEventListener('load', loadModelConfig);
    </script>
</body>
</html>
